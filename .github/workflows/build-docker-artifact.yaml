name: "Build tt-metal docker artifact"

on:
  workflow_call:
    inputs:
      distro:
        required: false
        type: string
        default: "ubuntu"
      version:
        required: false
        type: string
        default: "20.04"
      architecture:
        required: false
        type: string
        default: "amd64"
    outputs:
      # BTW we've been using the dev tag everywhere for this in downstream
      # jobs... might be a bit of a chore to validate very pipeline that we run
      # Docker on hasn't been using something that is only in dev
      ci-build-tag:
        description: "Docker tag for the CI Build Docker image for building TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.ci-build-tag }}
      #ci-test-tag:
      #  description: "Docker tag for the CI Test Docker image for testing TT-Metalium et al"
      #  value: ${{ jobs.check-docker-images.outputs.ci-test-tag }}
      dev-tag:
        description: "Docker tag for the Dev Docker image for developers working on TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.dev-tag }}
  workflow_dispatch:
    inputs:
      distro:
        required: false
        type: choice
        default: "ubuntu"
        options:
            - "ubuntu"
      version:
        required: false
        type: choice
        default: "20.04"
        options:
            - "20.04"
            - "22.04"
            - "24.04"
      architecture:
        required: false
        type: choice
        default: "amd64"
        options:
            - "amd64"

# env:
  # BRRRRR GOTTA CHANGE THE DEV IN HERE !!! Gotta permeate it...
  # IMAGE_NAME: ${{ inputs.distro }}-${{ inputs.version }}-dev-${{ inputs.architecture }}

jobs:
  check-docker-images:
    runs-on: ubuntu-latest
    outputs:
      ci-build-tag: ${{ steps.tags.outputs.ci-build-tag }}
      ci-build-exists: ${{ steps.images.outputs.ci-build-exists }}
      # ci-test-tag: ${{ steps.tags.outputs.ci-test-tag }}
      # ci-test-exists: ${{ steps.images.outputs.ci-test-exists }}
      dev-tag: ${{ steps.tags.outputs.dev-tag }}
      dev-exists: ${{ steps.images.outputs.dev-exists }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Compute tags
        id: tags
        run: |
          BUILD_TAG=$(cat \
            install_dependencies.sh \
            dockerfile/Dockerfile \
            tt_metal/python_env/requirements-dev.txt \
            docs/requirements-docs.txt \
            tests/sweep_framework/requirements-sweeps.txt \
            | sha1sum | cut -d' ' -f1)
          BUILD_IMAGE_NAME=${{ inputs.distro }}-${{ inputs.version }}-ci-build-${{ inputs.architecture }}
          echo "ci-build-tag=ghcr.io/${{ github.repository }}/tt-metalium/${BUILD_IMAGE_NAME}:${BUILD_TAG}" >> $GITHUB_OUTPUT

          # TODO: When we have multiple Docker images, do something like this:
          # TEST_TAG=$(cat tt_metal/python_env/requirements-dev.txt pyproject.toml | sha1sum | cut -d' ' -f1)
          # echo "ci-test-tag=ghcr.io/${{ github.repository }}/tt-metalium/${TEST_IMAGE_NAME}:${TEST_TAG}" >> $GITHUB_OUTPUT

          # Since we are calling everything ci-build, we will just make sure that
          # poc works, but we eventually will use $TEST_TAG here
          DEV_TAG=$(echo $BUILD_TAG \
            | sha1sum | cut -d' ' -f1)
          DEV_IMAGE_NAME=${{ inputs.distro }}-${{ inputs.version }}-dev-${{ inputs.architecture }}
          echo "dev-tag=ghcr.io/${{ github.repository }}/tt-metalium/${DEV_IMAGE_NAME}:${BUILD_TAG}" >> $GITHUB_OUTPUT

      - name: Query images exist
        id: images
        run: |
          if docker manifest inspect ${{ steps.tags.outputs.ci-build-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.ci-build-tag }} exists"
            echo "ci-build-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.ci-build-tag }} does not exist"
            echo "ci-build-exists=false" >> $GITHUB_OUTPUT
          fi

          if docker manifest inspect ${{ steps.tags.outputs.dev-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.dev-tag }} exists"
            echo "dev-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.dev-tag }} does not exist"
            echo "dev-exists=false" >> $GITHUB_OUTPUT
          fi

  build-docker-image:
    name: "üê≥Ô∏è Build image"
    needs: check-docker-images
    if: needs.check-docker-images.outputs.ci-build-exists != 'true' && needs.check-docker-images.outputs.dev-exists != 'true'
    timeout-minutes: 30
    runs-on:
      - build-docker
      - in-service
    steps:
      - uses: tenstorrent/tt-metal/.github/actions/checkout-with-submodule-lfs@main
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build ci-test Docker image and push to GHCR
        uses: docker/build-push-action@v6
        if: ${{ needs.check-docker-images.outputs.ci-build-exists != 'true' }}
        with:
          context: ${{ github.workspace }}
          # HRMM better to be explicit so we keep despite it being in different files now?
          # For now, for the sake of showing the team and not breaking other pipes,
          # call the ci-test target "ci-build" from the monolith Dockerfile
          # even though "ci-build" is the one used everywhere
          file: dockerfile/Dockerfile
          target: ci-test
          push: true
          tags: ${{ needs.check-docker-images.outputs.ci-build-tag }}
          build-args:
            - UBUNTU_VERSION=${{ inputs.version }}
            - IMAGE_ARCH=${{ inputs.architecture }}
          cache-to: type=inline
          pull: true
      - name: Build dev Docker image and push to GHCR
        uses: docker/build-push-action@v6
        if: ${{ needs.check-docker-images.outputs.dev-exists != 'true' }}
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.dev
          target: dev
          push: true
          tags: ${{ needs.check-docker-images.outputs.dev-tag }}
          # BASE_VERSION here must eventually be ci-test-tag
          build-args:
            - UBUNTU_VERSION=${{ inputs.version }}
            - IMAGE_ARCH=${{ inputs.architecture }}
            - BASE_IMAGE_TAG=${{ needs.check-docker-images.ci-build-tag }}
          cache-to: type=inline
          pull: true

  # Cannot use needs.build-docker-image to ensure this job runs sequentially after the build job because it would break when the build job is skipped
  # Instead, this setup causes the tag-latest job to lag one run behind the actual build.
  # However, this isn't a huge issue because the image should already have been built on a branch before merging, and if it wasn't (like in a push scenario),
  # the problem would self-correct on the next merge to main, which happens frequently.
  tag-latest:
    name: "üîÑ Update latest tag"
    needs: check-docker-images
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.check-docker-images.outputs.ci-build-exists == 'true' && needs.check-docker-images.outputs.dev-exists != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag and push latest
        run: |
          echo "fix me rk, IMAGE_NAME" && exit 1
          IMAGE_REPO="ghcr.io/${{ github.repository }}/tt-metalium/${{ env.IMAGE_NAME }}"
          LATEST_TAG="${IMAGE_REPO}:latest"
          BUILD_TAG="${{ needs.check-docker-images.outputs.ci-build-tag }}"
          echo "Tagging ${BUILD_TAG} as ${LATEST_TAG}"
          docker pull ${BUILD_TAG}
          docker tag ${BUILD_TAG} ${LATEST_TAG}
          docker push ${LATEST_TAG}
