#include <cstdint>

#define REDUCE_OP PoolType::SUM
#define REDUCE_DIM ReduceDim::REDUCE_ROW

#define BCAST_LLKOP EltwiseBinaryType::ELWMUL
#define BCAST_DIM BroadcastType::COL

#include "llk_3c.h"

#include "debug_print.h"

//#include "tt_metal/tools/profiler/kernel_profiler.hpp"

ALWI void ACQ() { acquire_dst(DstMode::Half); }
ALWI void REL() { release_dst(DstMode::Half); }


namespace NAMESPACE {
void MAIN {

    //kernel_profiler::mark_time(7);
    //kernel_profiler::init_profiler();
    constexpr uint32_t NCHt = get_compile_time_arg_val(0);
    constexpr uint32_t Wt = get_compile_time_arg_val(1);
    constexpr uint32_t do_gamma = get_compile_time_arg_val(2);
    constexpr uint32_t do_beta = get_compile_time_arg_val(3);

    //UNPACK(( DPRINT << "NC=" << NC << " Ht=" << Ht << " Wt=" << Wt << ENDL() ));
    binary_op_init_common(CB::c_in0, CB::c_in1);
        //UNPACK(( { DPRINT << "CB addr=" << HEX() << uint32_t(&cb_read_interface[0]) << ENDL(); } ));
    constexpr uint32_t onetile = 1;
    // reserve one tile for zeros on cb_in2
    // TODO(AP): check that if DST is indeed zeroed by release_dst (and initially), we can use it as zeroes

    // We only do the reserve for the intermediates once and use pack_tile
    // So effectively these are used as pre-allocated arrays
    // Note that the entire W dimension must fit in the intermed0 CB for this kernel to be correct
    constexpr auto cb_scaler = CB::c_in2; // single tile generated by the reader
    constexpr auto cb_eps = CB::c_in3; // single tile generated by the reader
    constexpr auto cb_col1 = CB::c_in4; // single tile generated by the reader
    constexpr auto cb_xmm = CB::c_intermed0; // x minus mean, this is a large buffer (128 tiles, see setup code in layernorm_op.cpp)
    constexpr auto cb_ex = CB::c_intermed1; // E[x]
    constexpr auto cb_ex2 = CB::c_intermed2; // E[(x-E[x])^2]
    constexpr auto cb_xmm2 = CB::c_intermed3; // xmm^2
    constexpr auto cb_savex = cb_xmm2; // aka
    constexpr auto cb_ex2pe = CB::c_intermed4; // E[(x-E[x])^2]+eps
    constexpr auto cb_in = CB::c_in0; // input
    constexpr auto cb_out = CB::c_out0; // output
    constexpr auto cb_gamma = CB::c_in5;
    constexpr auto cb_beta = CB::c_in6;
    constexpr auto cb_stream = CB::c_intermed5; // stream gamma/beta
    constexpr auto ndst = BLOCK_SIZE; // configurable size of DST block, use 1,2 for stress testing
    constexpr auto scaler0 = 0;
    //constexpr auto cb_exps1 = CB::c_intermed4;

    cb_wait_front(cb_scaler, 1); // comes from the reader
    cb_wait_front(cb_eps, 1); // comes from the reader
    cb_wait_front(cb_col1, 1); // comes from the reader
            //UNPACK(( { DPRINT  << TSLICE(cb_scaler, 0, 32, 0, 1) << ENDL(); } ));
            //UNPACK(( { DPRINT  << "====== Wt=" << Wt << ENDL(); } ));

    constexpr int cb_im_or_out = (do_gamma|do_beta) ? cb_stream : CB::c_out0;
    UNPACK(( DPRINT << "TR Gamma = " << do_gamma << " beta=" << do_beta << ENDL() ));
    UNPACK(( DPRINT << "cb out id=" << cb_im_or_out << ENDL() ));

    uint32_t nwait_g = 0, nwait_b = 0;

    for (uint32_t nc = 0; nc < NCHt; nc++) {

        constexpr int onetile = 1;
        constexpr int dst0 = 0;
        auto s8 = SliceRange::hw0_32_8();
        auto s16 = SliceRange::hw0_32_16();
        //auto h032 = SliceRange::h0_32_w0();
        //auto h0w032 = SliceRange::h0_w0_32();
        //auto h9w26 = SliceRange{.h0 = 9, .h1 = 10, .hs = 1, .w0 = 26, .w1 = 27, .ws = 1};
        //DPRINT << FIXP() << SETW(4) << SETP(3);
            // means = tensor.reduce(x, RSUM, RW, 1.0/W) # -> NCH1
            ACQ();
            cb_reserve_back(cb_ex, 1*onetile);
            reduce_init_delta_v2<false>(REDUCE_OP, REDUCE_DIM);
            uint32_t nwait = 0;
            for (uint32_t wt = 0; wt < Wt; wt += ndst) {
                nwait += ndst; // cb_wait_front currently needs to use a cumulative number in each call if we don't wait/pop the same number of tiles
                cb_wait_front(cb_in, nwait);
                for (uint32_t j = 0; j < ndst; j++) {
                    //UNPACK(( DPRINT  << "rem=" << U32(rem) << ENDL() ));
                    //if (ht == 0 && wt == 16) { UNPACK(( { DPRINT  << "x: " << wt+j << ENDL(); } )); }
                    //if (ht == 0 && wt == 16) { UNPACK(( { DPRINT  << TSLICE8(cb_in, wt+j, s16) << ENDL(); } )); }
                    //UNPACK(( DPRINT << "wt=" << wt << " j=" << j << ENDL() ));
                    //UNPACK(( { DPRINT << "CB addr=" << HEX() << uint32_t(&cb_read_interface[0]) << ENDL(); } ));
                    //if (ht >= 0 && wt+j >= 0) { UNPACK(( { DPRINT  << "x: ht=" << ht << " wt=" << wt+j << ENDL(); } )); }
                    //if (ht >= 0 && wt+j >= 0) { UNPACK(( { DPRINT  << TSLICE8(cb_in, wt+j, s16) << ENDL(); } )); }
                    reduce_tile_v2(REDUCE_OP, REDUCE_DIM, cb_in, cb_scaler, wt+j, scaler0, dst0);
                }
                // we don't pop cb_in until we compute Ex
            }
            reduce_revert_delta_v2();

            pack_tile(dst0, cb_ex);
            REL();
                    //if (ht == 3) PACK((   DPRINT  << "E[x]:" << ENDL() ));
                    //if (ht == 3) PACK(( { DPRINT  << TSLICE(cb_ex, 0, s8) << ENDL(); } ));
            cb_push_back(cb_ex, 1);

            // compute xmm=x-mean. Reuse cb_in since we didn't pop anything from it
            cb_wait_front(cb_ex, 1); // should have 1 tile
            cb_reserve_back(cb_xmm, Wt);
            sub_bcast_cols_init_short();
            for (uint32_t wt = 0; wt < Wt; wt += ndst) {
                ACQ();
                for (uint32_t wtr = 0; wtr<ndst; wtr++) {
                        //UNPACK(( { if (ht == 3 && wt+wtr >= 0) DPRINT  << "x:" << wt+wtr << ENDL(); } ));
                        //UNPACK(( { if (ht == 3 && wt+rem == 4) DPRINT  << U32(sizeof(TSLICE32)) << ENDL(); } ));
                        //UNPACK(( { if (ht == 3 && wt+wtr >= 0) DPRINT  << TSLICE8(cb_in, wt+wtr, s16) << ENDL(); } ));
                        //UNPACK(( { if (ht == 3 && wt+rem >= 4) DPRINT  << CB_RD_PTR(cb_in) << ENDL(); } ));
                        //if (ht >= 0 && wt+wtr >= 0) { UNPACK(( { DPRINT  << "x: ht=" << ht << " wt=" << wt+wtr << ENDL(); } )); }
                        //if (ht >= 0 && wt+wtr >= 0) { UNPACK(( { DPRINT  << TSLICE8(cb_in, wt+wtr, s16) << ENDL(); } )); }
                        //UNPACK(( { for(volatile int i = 0; i < 10000000; i++) ; } )) ;
                    sub_tiles_bcast_cols(cb_in, cb_ex, wt+wtr, 0, wtr); // tile *= 1/(sum(exp(x)))
                    pack_tile(wtr, cb_xmm);
                        //PACK(( { if (ht == 3 && wt+wtr >= 4) DPRINT << "xmm[" << ht << "," << wt+wtr << "]" << ENDL(); } ));
                        //PACK(( { if (ht == 3 && wt+wtr >= 4) DPRINT << TSLICE(cb_xmm, wt+wtr, s8) << ENDL(); } ));
                }
                cb_push_back(cb_xmm, ndst);
                    //PACK(( DPRINT << "Pushing to xmm" << wt << " " << ndst << ENDL() ));
                REL();
            }
            cb_pop_front(cb_ex, 1);
            cb_pop_front(cb_in, Wt);

            // compute temp = xmm*xmm = (x-E[x])^2
            mul_tiles_init();
            nwait = 0;
            for (uint32_t wt = 0; wt < Wt; wt += ndst) {
                nwait += ndst;
                cb_wait_front(cb_xmm, nwait);
                cb_reserve_back(cb_xmm2, ndst); // can probably use less space for this if we block
                ACQ();
                for (uint32_t wtr = 0; wtr<ndst; wtr++) {
                        //if ((ht == 0) && wt+wtr>=16) UNPACK(( DPRINT << "xmm in xmm2[" << ht << "," << wt+wtr << "]" << ENDL() ));
                        //if ((ht == 3) && wt+wtr>=4) UNPACK(( DPRINT << "rdtiles=" << CB_RD_SZ(cb_xmm) << " " << CB_RD_LIM(cb_xmm) << ENDL() ));
                        //if ((ht == 3) && wt+wtr>=4) UNPACK(( DPRINT << TSLICE8(cb_xmm, wt+wtr, s16) << ENDL() ));
                    mul_tiles(cb_xmm, cb_xmm, wt+wtr, wt+wtr, wtr);
                    pack_tile(wtr, cb_xmm2);
                        //if ((ht == 0) && wt+wtr>=16) PACK(( DPRINT << "xmm2[" << ht << "," << wt+wtr << "]" << ENDL() ));
                        //if ((ht == 0) && wt+wtr>=16) PACK(( DPRINT << TSLICE8(cb_xmm2, wtr, s16) << ENDL() ));
                }
                cb_push_back(cb_xmm2, ndst);
                REL();
            }

            // compute E[(x-E[x])^2]
            // IIRC E[x^2] - E[x]^2 trick was unstable
            // TODO(AP): can save space here by reusing CB
            cb_reserve_back(cb_ex2, 1);
            reduce_init_delta_v2<false>(REDUCE_OP, REDUCE_DIM);
            ACQ();
            cb_wait_front(cb_xmm2, Wt);
            for (uint32_t wt = 0; wt < Wt; wt += ndst) {
                // reduce
                for (uint32_t wtr = 0; wtr<ndst; wtr++)
                    //reduce_tile_v2(REDUCE_OP, REDUCE_DIM, cb_xmm2, cb_scaler, wtr, scaler0, dst0);
                    reduce_tile_v2(REDUCE_OP, REDUCE_DIM, cb_xmm2, cb_scaler, wt+wtr, scaler0, dst0);
            }
            cb_pop_front(cb_xmm2, Wt);
            reduce_revert_delta_v2();
            pack_tile(dst0, cb_ex2);
                        //if (ht == 3) PACK(( DPRINT << "exmm2[" << ht << "," << 0 << "]" << ENDL() ));
                        //if (ht == 3) PACK(( DPRINT << TSLICE(cb_ex2, 0, s8) << ENDL() ));
            REL();

            cb_push_back(cb_ex2, 1);
            cb_wait_front(cb_ex2, 1);

            //cb_reserve_back(cb_debug, 1);

            ACQ();
            // add epsilon E[(x-E[x])^2]+eps
            {
                add_tiles_init();
                        //UNPACK(( DPRINT  << "cb_ex2:" << ENDL() ));
                        //UNPACK(( DPRINT  << TSLICE(cb_ex2, 0, s8) << ENDL() ));
                        //UNPACK(( DPRINT  << "eps:" << ENDL() ));
                        //for (int j = 0; j<32; j++) { UNPACK(( DPRINT  << TSLICE(cb_eps, 0, h0w032) << ENDL() )); h0w032.h0++; h0w032.h1++; }
                add_tiles(cb_ex2, cb_eps, 0, 0, dst0);

                cb_reserve_back(cb_ex2pe, 1); // 1
                //pack_tile(dst0, cb_debug);
                pack_tile(dst0, cb_ex2pe);
                        //if (ht == 2) PACK(( DPRINT  << "eps:" << ENDL() ));
                        //if (ht == 2) for (int j = 0; j<32; j++) { PACK(( DPRINT  << TSLICE(cb_eps, 0, h0w032) << ENDL() )); h0w032.h0++; h0w032.h1++; }
                        //if (ht == 2) PACK(( DPRINT  << "exmm2pe:" << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_debug, 0, s8) << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_ex2pe, 0, s8) << ENDL() ));
                cb_push_back(cb_ex2pe, 1);
            }
            REL();

            cb_pop_front(cb_ex2, 1);

            cb_wait_front(cb_ex2pe, 1);
            cb_reserve_back(cb_ex2pe, 1); // 2

            ACQ();
            { // sqrt( E[(x-E[x])^2] + eps )
                copy_tile_init();
                copy_tile(cb_ex2pe, 0, 0);
                cb_pop_front(cb_ex2pe, 1); // 1
                sqrt_tile_init();
                sqrt_tile(0);
                pack_tile(0, cb_ex2pe);
                        //if (ht == 2) PACK(( DPRINT  << "sqrt_exmm2pe:" << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_ex2pe, 0, s8) << ENDL() ));
                cb_push_back(cb_ex2pe, 1);
            }
            REL();

            // mask out incorrect values right of [:, 0:1]
            cb_wait_front(cb_ex2pe, 1);
            cb_reserve_back(cb_ex2pe, 1); // 2


            ACQ();
            { // 1.0 / sqrt( E[(x-E[x])^2] + eps )
                copy_tile_init();
                copy_tile(cb_ex2pe, 0, dst0);
                cb_pop_front(cb_ex2pe, 1); // 1
                recip_tile_init();
                recip_tile(dst0);
                pack_tile(dst0, cb_ex2pe);
                        //if (ht == 2) PACK(( DPRINT  << "1/sqrt_exmm2pe:" << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_ex2pe, 0, s8) << ENDL() ));
                cb_push_back(cb_ex2pe, 1);
            }
            REL();

            cb_reserve_back(cb_ex2pe, 1); // 2
            cb_wait_front(cb_ex2pe, 1);

            ACQ();
            { // mask_col( 1.0 / sqrt( E[(x-E[x])^2] + eps ) )
                mul_tiles_init();
                mul_tiles(cb_ex2pe, cb_col1, 0, 0, dst0);
                cb_pop_front(cb_ex2pe, 1);
                pack_tile(dst0, cb_ex2pe);
                        //if (ht == 2) PACK(( DPRINT  << "mask_col1_sqrt_exmm2pe:" << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_col1, 0, s8) << ENDL() ));
                        //if (ht == 2) PACK(( DPRINT  << TSLICE(cb_ex2pe, 0, s8) << ENDL() ));
            }
            REL();
            cb_push_back(cb_ex2pe, 1);

            cb_reserve_back(cb_ex2pe, 1); // 2
            cb_wait_front(cb_ex2pe, 1);

            // now xmm = (x-E[x])
            // we have 1.0/sqrt( E[(x-E[x])^2] + eps) in cb_ex2pe
            // just need to bcast_mul
            cb_wait_front(cb_ex2pe, 1);
            for (uint32_t wt = 0; wt < Wt; wt += ndst) {
                            //if (ht == 1) UNPACK(( DPRINT << "wt_2=" << wt << " " ));
                            //if (ht == 1) UNPACK(( DPRINT << "rem_2=" << rem << ENDL() ));
                cb_reserve_back(cb_im_or_out, ndst);

                ACQ();
                mul_bcast_cols_init_short();
                for (uint32_t wtr = 0; wtr < ndst; wtr++) {
                        //UNPACK(( DPRINT << "ExpsInBcast:[" << ht << "," << wt << "]" << ENDL() ));
                        //UNPACK(( DPRINT << TSLICE(cb_exps, wt+wtr, s8) << ENDL() ));
                        //UNPACK(( DPRINT << "RecipsInBcast:" << ENDL() ));
                        //UNPACK(( DPRINT << TSLICE(cb_recips, 0, s8) << ENDL() ));
                    // cb_xmm[wt+wtr] since we pop Wt from cb_xmm after the entire loop
                    mul_tiles_bcast_cols(cb_xmm, cb_ex2pe, wt+wtr, 0, wtr); // tile *= 1/(sum(exp(x)))
                    pack_tile(wtr, cb_im_or_out); // pack either to intermediate (cb_stream or out0)
                        //if (ht == 3 && wt+wtr==3) PACK(( DPRINT << "xmm/v2eps[" << ht << "," << wt+wtr << "]" << ENDL() ));
                        //if (ht == 3 && wt+wtr==3) PACK(( DPRINT << TSLICE(CB::c_out0, 0, h9w26) << ENDL() ));
                        //if (ht == 3 && wt+wtr==3) PACK(( DPRINT << TSLICE(CB::c_out0, 0, s8) << ENDL() ));
                }
                REL();

                cb_push_back(cb_im_or_out, ndst);
                    if (do_gamma) {
                        ACQ();
                        if (nwait_g < Wt)
                            nwait_g += ndst; // cumulative
                        uint32_t cb_outg = do_beta ? cb_stream : CB::c_out0;
                        cb_wait_front(cb_stream, ndst);
                        //UNPACK(( DPRINT << "wait gamma=" << nwait_g << ENDL() ));
                        cb_wait_front(cb_gamma, nwait_g);
                        mul_bcast_rows_init_short();
                        for (uint32_t wtr = 0; wtr < ndst; wtr++) {
                            mul_tiles_bcast_rows(cb_stream, cb_gamma, wtr, wt+wtr, wtr); // tile *= 1/(sum(exp(x)))
                            pack_tile(wtr, cb_outg); // pack either to intermediate (cb_stream or out0)
                        }
                        cb_pop_front(cb_stream, ndst);
                        // we don't pop gamma
                        //UNPACK(( DPRINT << "cb_outg=" << cb_outg << ENDL() ));
                        cb_push_back(cb_outg, ndst);
                        REL();
                    }
                    if (do_beta) {
                        ACQ();
                        if (nwait_b < Wt)
                            nwait_b += ndst;
                        add_bcast_rows_init_short();
                        cb_wait_front(cb_stream, ndst);
                        cb_wait_front(cb_beta, nwait_b);
                        for (uint32_t wtr = 0; wtr < ndst; wtr++) {
                            add_tiles_bcast_rows(cb_stream, cb_beta, wtr, wt+wtr, wtr); // tile *= 1/(sum(exp(x)))
                            pack_tile(wtr, CB::c_out0); // pack either to intermediate (cb_stream or out0)
                        }
                        cb_pop_front(cb_stream, ndst);
                        // we don't pop beta
                        cb_push_back(CB::c_out0, ndst);
                        REL();
                    }
            }
            cb_pop_front(cb_ex2pe, 1); // 0
            cb_pop_front(cb_xmm, Wt);
    } // NCHt loop
    //kernel_profiler::mark_time(8);
    //cb_pop_front(cb_scaler, 1); // optional for correctness
    //cb_pop_front(cb_eps, 1); // optional for correctness
    //cb_pop_front(cb_col1, 1); // optional for correctness
}
}
