// SPDX-FileCopyrightText: Â© 2023 Tenstorrent Inc.
//
// SPDX-License-Identifier: Apache-2.0

#include "{{ snake_operation_name }}_op.hpp"

namespace {{ full_namespace }} {
// Your C++ code here
{{ operation_name }}::program_factory_t Binary::select_program_factory(
    const operation_attributes_t& operation_attributes, const tensor_args_t& tensor_args) {
    ZoneScopedN("{{ operation_name }}::select_program_factory");

    // Update to your op
}

void {{ operation_name }}::validate_on_program_cache_miss(
    const operation_attributes_t& attributes, const tensor_args_t& tensor_args) {
    const auto& input_tensor_a = tensor_args.input_tensor_a;
    const auto& input_tensor_b = tensor_args.input_tensor_b;
    const auto& output_tensor = tensor_args.output_tensor;

    {{ operation_name }}::validate_on_program_cache_hit(attributes, tensor_args);

    // Update to your op
}
void {{ operation_name }}::validate_on_program_cache_hit(const operation_attributes_t& attributes, const tensor_args_t& tensor_args) {
    // Update to your op
}

{{ operation_name }}::shape_return_value_t Binary::compute_output_shapes(
    const operation_attributes_t&, const tensor_args_t& tensor_args) {
    // Update to your op
}

{{ operation_name }}::tensor_return_value_t Binary::create_output_tensors(
    const operation_attributes_t& operation_attributes, const tensor_args_t& tensor_args) {
    auto output_shape = compute_output_shapes(operation_attributes, tensor_args);
    const auto& input_tensor_a = tensor_args.input_tensor_a;
    const auto& input_tensor_b = tensor_args.input_tensor_b;
    const auto& output_tensor = tensor_args.output_tensor;

    if (output_tensor.has_value()) {
        return output_tensor.value();
    }
    // Update to your Op
}

tt::stl::hash::hash_t {{ operation_name }}::compute_program_hash(
    const operation_attributes_t& attributes, const tensor_args_t& tensor_args) {
    const auto& input_tensor_a = tensor_args.input_tensor_a;
    const auto& input_tensor_b = tensor_args.input_tensor_b;

    auto program_factory = select_program_factory(attributes, tensor_args);
    TT_ASSERT(std::holds_alternative<DeviceStorage>(input_tensor_a.get_storage()), fmt::format("Unexpected type {} in {}:{} ",tt::stl::get_active_type_name_in_variant(input_tensor_a.get_storage()),__FILE__, __LINE__));
    TT_ASSERT(std::holds_alternative<DeviceStorage>(input_tensor_b.get_storage()), fmt::format("Unexpected type {} in {}:{} ",tt::stl::get_active_type_name_in_variant(input_tensor_b.get_storage()),__FILE__, __LINE__));
    operation::Hash hash = operation::hash_operation<{{ operation_name }}>(
        attributes,
        program_factory.index(),
        input_tensor_a.dtype(),
        std::get<DeviceStorage>(input_tensor_a.storage()).memory_config(),
        input_tensor_b.dtype(),
        std::get<DeviceStorage>(input_tensor_b.storage()).memory_config());
    return hash;
}

operation::OpPerformanceModel {{ operation_name }}::create_op_performance_model(
    const operation_attributes_t& attributes,
    const tensor_args_t& tensor_args,
    tensor_return_value_t& tensor_return_value) {

    operation::OpPerformanceModel result();
    return result;
}

}  // namespace {{ full_namespace }}
